{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8ce79f94_4834be72",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000161
      },
      "writtenOn": "2024-11-06T15:38:04Z",
      "side": 1,
      "message": "@flokli@flokli.de I am seeing \"llama\" failing for the second time but not sure how to repro this locally, any suggestions? thanks",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba9a571c_426df7d6",
        "filename": "tvix/nix-compat/Cargo.toml",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:39:22Z",
      "side": 1,
      "message": "this will most likely break the nix build because of a circular dependency between nix-compat -\u003e nix-compat-derive -\u003e nix-compat\nIt works with cargo because it allows this because nix-compat-derive -\u003e nix-compat is a dev-dependency but crate2nix does not allow this.\n\nI believe nix-compat-derive depends on nix-compat for doctests.",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f85ae7d_3d1883f4",
        "filename": "tvix/nix-compat/Cargo.toml",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000161
      },
      "writtenOn": "2024-11-06T15:48:45Z",
      "side": 1,
      "message": "Oh, that could explain why I am seeing llama failing with \"infinite recursion\"(?), thanks that\u0027s good to know.\n\n\u003e I believe nix-compat-derive depends on nix-compat for doctests.\n\n@me@griff.name One thing that I\u0027ve been thinking is we can completely break the dependency by moving `Nix{Des,S}erialize` traits and impls into `nix-compat-derive` and renaming the crate to say `nix-serialization`. It could have an optional \"derive\" feature, this would make this crate decoupled from tvix and more generally useful and applicable. wdyt?",
      "parentUuid": "ba9a571c_426df7d6",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d0e25bb_cd36331a",
        "filename": "tvix/nix-compat/Cargo.toml",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:59:42Z",
      "side": 1,
      "message": "I don\u0027t think you can do that because proc-crates can\u0027t export traits and structs like that. I might be wrong thought.",
      "parentUuid": "3f85ae7d_3d1883f4",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89b8c46d_ed4e78e2",
        "filename": "tvix/nix-compat/Cargo.toml",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T16:05:59Z",
      "side": 1,
      "message": "Also nix-serialization is really only useful for Nix Daemon protocol, maybe Nix worker protocol (but that is legacy) and potentially NAR reading and writing (but that uses its own implementations in twix).\n\nAnd to implement the nix daemon protocol you need types that really mostly live in `nix-compat`.\n\nMoving would also not solve this problem as you would still need a `nix-serialization` crate and a `nix-serialization-derive` crate.",
      "parentUuid": "4d0e25bb_cd36331a",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42bc7354_bf1ef85e",
        "filename": "tvix/nix-compat/src/nix_daemon/containers.rs",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:55:21Z",
      "side": 1,
      "message": "why this hack instead of just implementing `NixSerialize` and `NixDeserialize` on `Option\u003cUnkeyedValidPathInfo\u003e`?\nIf you worry about redundant code use this macro:\n\n```\nmacro_rules! optional_info {\n    ($sub:ty) \u003d\u003e {\n        impl NixDeserialize for Option\u003c$sub\u003e {\n            fn try_deserialize\u003cR\u003e(\n                reader: \u0026mut R,\n            ) -\u003e impl std::future::Future\u003cOutput \u003d Result\u003cOption\u003cSelf\u003e, R::Error\u003e\u003e + Send + \u0027_\n            where\n                R: ?Sized + NixRead + Send,\n            {\n                async move {\n                    if let Some(found) \u003d reader.try_read_value::\u003cbool\u003e().await? {\n                        if found {\n                            Ok(Some(Some(reader.read_value().await?)))\n                        } else {\n                            Ok(Some(None))\n                        }\n                    } else {\n                        Ok(None)\n                    }\n                }\n            }\n        }\n        impl NixSerialize for Option\u003c$sub\u003e {\n            async fn serialize\u003cW\u003e(\u0026self, writer: \u0026mut W) -\u003e Result\u003c(), W::Error\u003e\n                where W: NixWrite\n            {\n                if let Some(value) \u003d self.as_ref() {\n                    writer.write_value(\u0026true).await?;\n                    writer.write_value(value).await\n                } else {\n                    writer.write_value(\u0026false).await\n                }\n            }\n        }\n    };\n}\noptional_info!(UnkeyedValidPathInfo);\n```",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5da25bea_6cf2ae46",
        "filename": "tvix/nix-compat/src/nix_daemon/containers.rs",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:55:21Z",
      "side": 1,
      "message": "Same question as above?\nWith a macro for it as well:\n```\nmacro_rules! optional_string {\n    ($sub:ty) \u003d\u003e {\n        impl NixDeserialize for Option\u003c$sub\u003e {\n            fn try_deserialize\u003cR\u003e(\n                reader: \u0026mut R,\n            ) -\u003e impl std::future::Future\u003cOutput \u003d Result\u003cOption\u003cSelf\u003e, R::Error\u003e\u003e + Send + \u0027_\n            where\n                R: ?Sized + NixRead + Send,\n            {\n                async move {\n                    if let Some(buf) \u003d reader.try_read_bytes().await? {\n                        let s \u003d std::str::from_utf8(\u0026buf).map_err(R::Error::invalid_data)?;\n                        if s \u003d\u003d \"\" {\n                            Ok(Some(None))\n                        } else {\n                            Ok(Some(Some(s.parse().map_err(R::Error::invalid_data)?)))\n                        }    \n                    } else {\n                        Ok(None)\n                    }\n                }\n            }\n        }\n        impl NixSerialize for Option\u003c$sub\u003e {\n            async fn serialize\u003cW\u003e(\u0026self, writer: \u0026mut W) -\u003e Result\u003c(), W::Error\u003e\n                where W: NixWrite\n            {\n                if let Some(value) \u003d self.as_ref() {\n                    writer.write_value(value).await\n                } else {\n                    writer.write_slice(b\"\").await\n                }\n            }\n        }\n    };\n}\noptional_string!(StorePath);\n```",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f02c8112_9b6dcc96",
        "filename": "tvix/nix-compat/src/nix_daemon/mod.rs",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:55:21Z",
      "side": 1,
      "message": "Why use `async_trait` here since it boxes all futures when there is now support for async traits directly in rust?",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87b354be_0970ea00",
        "filename": "tvix/nix-compat/src/nix_daemon/types.rs",
        "patchSetId": 4
      },
      "lineNbr": 8,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:55:21Z",
      "side": 1,
      "message": "This is always zero and ignored when read. That concept can be implemented generally like this:\n```\n#[derive(Clone, Debug)]\n#[derive(NixDeserialize, NixSerialize)]\n#[nix(from \u003d \"u64\", into \u003d \"u64\")]\npub struct IgnoredZero;\nimpl From\u003cu64\u003e for IgnoredZero {\n    fn from(_: u64) -\u003e Self {\n        IgnoredZero\n    }\n}\n\nimpl From\u003cIgnoredZero\u003e for u64 {\n    fn from(_: IgnoredZero) -\u003e Self {\n        0\n    }\n}\n```\n\nAnd then this line is just:\n```suggestion\n    _have_pos: IgnoredZero,\n```",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26e51693_2d5db3c5",
        "filename": "tvix/nix-compat/src/nix_daemon/worker_protocol.rs",
        "patchSetId": 4
      },
      "lineNbr": 132,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:55:21Z",
      "side": 1,
      "message": "@flokli@flokli.de can we please switch to the `num_enum` crate instead since with that we don\u0027t need this hack",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6119f57e_e8076f8a",
        "filename": "tvix/nix-compat/src/nix_daemon/worker_protocol.rs",
        "patchSetId": 4
      },
      "lineNbr": 154,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:55:21Z",
      "side": 1,
      "message": "@flokli@flokli.de or this hack",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    }
  ]
}