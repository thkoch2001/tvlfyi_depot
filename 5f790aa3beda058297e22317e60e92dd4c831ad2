{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8ce79f94_4834be72",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000161
      },
      "writtenOn": "2024-11-06T15:38:04Z",
      "side": 1,
      "message": "@flokli@flokli.de I am seeing \"llama\" failing for the second time but not sure how to repro this locally, any suggestions? thanks",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f19a6cc8_3d07c717",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T16:23:32Z",
      "side": 1,
      "message": "I have some code sketches of all the types used by the protocol as well as some work on a my version of the `NixDaemonIO` trait and logging.\n\nI didn\u0027t make a CL for it as it doesn\u0027t do anything functionally useful or completed but if you want to look at my sketches you are welcome.",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7ef3872_3d189254",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000036
      },
      "writtenOn": "2024-11-06T18:53:10Z",
      "side": 1,
      "message": "The log says:\n\n\u003e error: stack overflow (possible infinite recursion)\n\nYou can render the pipeline locally by running `nix-build -A ops.pipelines.depot -o pipeline`",
      "parentUuid": "8ce79f94_4834be72",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba9a571c_426df7d6",
        "filename": "tvix/nix-compat/Cargo.toml",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:39:22Z",
      "side": 1,
      "message": "this will most likely break the nix build because of a circular dependency between nix-compat -\u003e nix-compat-derive -\u003e nix-compat\nIt works with cargo because it allows this because nix-compat-derive -\u003e nix-compat is a dev-dependency but crate2nix does not allow this.\n\nI believe nix-compat-derive depends on nix-compat for doctests.",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f85ae7d_3d1883f4",
        "filename": "tvix/nix-compat/Cargo.toml",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000161
      },
      "writtenOn": "2024-11-06T15:48:45Z",
      "side": 1,
      "message": "Oh, that could explain why I am seeing llama failing with \"infinite recursion\"(?), thanks that\u0027s good to know.\n\n\u003e I believe nix-compat-derive depends on nix-compat for doctests.\n\n@me@griff.name One thing that I\u0027ve been thinking is we can completely break the dependency by moving `Nix{Des,S}erialize` traits and impls into `nix-compat-derive` and renaming the crate to say `nix-serialization`. It could have an optional \"derive\" feature, this would make this crate decoupled from tvix and more generally useful and applicable. wdyt?",
      "parentUuid": "ba9a571c_426df7d6",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d0e25bb_cd36331a",
        "filename": "tvix/nix-compat/Cargo.toml",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:59:42Z",
      "side": 1,
      "message": "I don\u0027t think you can do that because proc-crates can\u0027t export traits and structs like that. I might be wrong thought.",
      "parentUuid": "3f85ae7d_3d1883f4",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89b8c46d_ed4e78e2",
        "filename": "tvix/nix-compat/Cargo.toml",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T16:05:59Z",
      "side": 1,
      "message": "Also nix-serialization is really only useful for Nix Daemon protocol, maybe Nix worker protocol (but that is legacy) and potentially NAR reading and writing (but that uses its own implementations in twix).\n\nAnd to implement the nix daemon protocol you need types that really mostly live in `nix-compat`.\n\nMoving would also not solve this problem as you would still need a `nix-serialization` crate and a `nix-serialization-derive` crate.",
      "parentUuid": "4d0e25bb_cd36331a",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d60c0f1_9bfe99eb",
        "filename": "tvix/nix-compat/Cargo.toml",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000161
      },
      "writtenOn": "2024-11-06T18:14:58Z",
      "side": 1,
      "message": "I think this should remove the dep cycle and improve ergonomics a bit https://cl.tvl.fyi/c/depot/+/12738 . wdyt?",
      "parentUuid": "89b8c46d_ed4e78e2",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b0197779_dc7c72c7",
        "filename": "tvix/nix-compat/Cargo.toml",
        "patchSetId": 4
      },
      "lineNbr": 26,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T19:17:20Z",
      "side": 1,
      "message": "No because `nix-serialize` would depend on `nix-serialize-derive` which would depend on `nix-serialize` for doctests. So you would need this same `derive` feature flag as `nix-compat` currently uses to avoid the circular dependency.",
      "parentUuid": "2d60c0f1_9bfe99eb",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "42bc7354_bf1ef85e",
        "filename": "tvix/nix-compat/src/nix_daemon/containers.rs",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:55:21Z",
      "side": 1,
      "message": "why this hack instead of just implementing `NixSerialize` and `NixDeserialize` on `Option\u003cUnkeyedValidPathInfo\u003e`?\nIf you worry about redundant code use this macro:\n\n```\nmacro_rules! optional_info {\n    ($sub:ty) \u003d\u003e {\n        impl NixDeserialize for Option\u003c$sub\u003e {\n            fn try_deserialize\u003cR\u003e(\n                reader: \u0026mut R,\n            ) -\u003e impl std::future::Future\u003cOutput \u003d Result\u003cOption\u003cSelf\u003e, R::Error\u003e\u003e + Send + \u0027_\n            where\n                R: ?Sized + NixRead + Send,\n            {\n                async move {\n                    if let Some(found) \u003d reader.try_read_value::\u003cbool\u003e().await? {\n                        if found {\n                            Ok(Some(Some(reader.read_value().await?)))\n                        } else {\n                            Ok(Some(None))\n                        }\n                    } else {\n                        Ok(None)\n                    }\n                }\n            }\n        }\n        impl NixSerialize for Option\u003c$sub\u003e {\n            async fn serialize\u003cW\u003e(\u0026self, writer: \u0026mut W) -\u003e Result\u003c(), W::Error\u003e\n                where W: NixWrite\n            {\n                if let Some(value) \u003d self.as_ref() {\n                    writer.write_value(\u0026true).await?;\n                    writer.write_value(value).await\n                } else {\n                    writer.write_value(\u0026false).await\n                }\n            }\n        }\n    };\n}\noptional_info!(UnkeyedValidPathInfo);\n```",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ba2f168b_2b0e965f",
        "filename": "tvix/nix-compat/src/nix_daemon/containers.rs",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1000161
      },
      "writtenOn": "2024-11-06T18:14:58Z",
      "side": 1,
      "message": "Oh, that\u0027s a great point will do",
      "parentUuid": "42bc7354_bf1ef85e",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5da25bea_6cf2ae46",
        "filename": "tvix/nix-compat/src/nix_daemon/containers.rs",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:55:21Z",
      "side": 1,
      "message": "Same question as above?\nWith a macro for it as well:\n```\nmacro_rules! optional_string {\n    ($sub:ty) \u003d\u003e {\n        impl NixDeserialize for Option\u003c$sub\u003e {\n            fn try_deserialize\u003cR\u003e(\n                reader: \u0026mut R,\n            ) -\u003e impl std::future::Future\u003cOutput \u003d Result\u003cOption\u003cSelf\u003e, R::Error\u003e\u003e + Send + \u0027_\n            where\n                R: ?Sized + NixRead + Send,\n            {\n                async move {\n                    if let Some(buf) \u003d reader.try_read_bytes().await? {\n                        let s \u003d std::str::from_utf8(\u0026buf).map_err(R::Error::invalid_data)?;\n                        if s \u003d\u003d \"\" {\n                            Ok(Some(None))\n                        } else {\n                            Ok(Some(Some(s.parse().map_err(R::Error::invalid_data)?)))\n                        }    \n                    } else {\n                        Ok(None)\n                    }\n                }\n            }\n        }\n        impl NixSerialize for Option\u003c$sub\u003e {\n            async fn serialize\u003cW\u003e(\u0026self, writer: \u0026mut W) -\u003e Result\u003c(), W::Error\u003e\n                where W: NixWrite\n            {\n                if let Some(value) \u003d self.as_ref() {\n                    writer.write_value(value).await\n                } else {\n                    writer.write_slice(b\"\").await\n                }\n            }\n        }\n    };\n}\noptional_string!(StorePath);\n```",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8fd835fc_c0e6516d",
        "filename": "tvix/nix-compat/src/nix_daemon/containers.rs",
        "patchSetId": 4
      },
      "lineNbr": 80,
      "author": {
        "id": 1000161
      },
      "writtenOn": "2024-11-06T18:14:58Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "5da25bea_6cf2ae46",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f02c8112_9b6dcc96",
        "filename": "tvix/nix-compat/src/nix_daemon/mod.rs",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:55:21Z",
      "side": 1,
      "message": "Why use `async_trait` here since it boxes all futures when there is now support for async traits directly in rust?",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f5ee27d7_8d4d5478",
        "filename": "tvix/nix-compat/src/nix_daemon/mod.rs",
        "patchSetId": 4
      },
      "lineNbr": 15,
      "author": {
        "id": 1000161
      },
      "writtenOn": "2024-11-06T18:14:58Z",
      "side": 1,
      "message": "\u003e now support for async traits directly in rust\n\nSuch traits are not object-safe and I am using Arc\u003cdyn NixDaemonIO\u003e throughout, I can look more into this and make NixDaemon(server) generic over NixDaemonIO though.",
      "parentUuid": "f02c8112_9b6dcc96",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "87b354be_0970ea00",
        "filename": "tvix/nix-compat/src/nix_daemon/types.rs",
        "patchSetId": 4
      },
      "lineNbr": 8,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:55:21Z",
      "side": 1,
      "message": "This is always zero and ignored when read. That concept can be implemented generally like this:\n```\n#[derive(Clone, Debug)]\n#[derive(NixDeserialize, NixSerialize)]\n#[nix(from \u003d \"u64\", into \u003d \"u64\")]\npub struct IgnoredZero;\nimpl From\u003cu64\u003e for IgnoredZero {\n    fn from(_: u64) -\u003e Self {\n        IgnoredZero\n    }\n}\n\nimpl From\u003cIgnoredZero\u003e for u64 {\n    fn from(_: IgnoredZero) -\u003e Self {\n        0\n    }\n}\n```\n\nAnd then this line is just:\n```suggestion\n    _have_pos: IgnoredZero,\n```",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5afe2788_23aa0052",
        "filename": "tvix/nix-compat/src/nix_daemon/types.rs",
        "patchSetId": 4
      },
      "lineNbr": 23,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T16:23:32Z",
      "side": 1,
      "message": "This is very much not always a UTF-8 string in the protocol. So while our daemon might not send anything other than UTF-8, a client that talks to CppNix would not be so lucky.",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f752c89d_dc996b1f",
        "filename": "tvix/nix-compat/src/nix_daemon/types.rs",
        "patchSetId": 4
      },
      "lineNbr": 63,
      "author": {
        "id": 1000036
      },
      "writtenOn": "2024-11-06T19:03:02Z",
      "side": 1,
      "message": "Hmmh, it\u0027s a bit annoying we have our own type here.\n\nI assume it won\u0027t be easy to allow deserializing into `nix_compat::store_path::StorePath`, would it?",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "26e51693_2d5db3c5",
        "filename": "tvix/nix-compat/src/nix_daemon/worker_protocol.rs",
        "patchSetId": 4
      },
      "lineNbr": 132,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:55:21Z",
      "side": 1,
      "message": "@flokli@flokli.de can we please switch to the `num_enum` crate instead since with that we don\u0027t need this hack",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "01eba5d7_640a1b40",
        "filename": "tvix/nix-compat/src/nix_daemon/worker_protocol.rs",
        "patchSetId": 4
      },
      "lineNbr": 132,
      "author": {
        "id": 1000036
      },
      "writtenOn": "2024-11-06T18:53:10Z",
      "side": 1,
      "message": "I\u0027m not the author of this CL, but I don\u0027t really see a reason why not. @v.kryachko@gmail.com?",
      "parentUuid": "26e51693_2d5db3c5",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e9d7eab5_58f719c4",
        "filename": "tvix/nix-compat/src/nix_daemon/worker_protocol.rs",
        "patchSetId": 4
      },
      "lineNbr": 132,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T19:17:20Z",
      "side": 1,
      "message": "@v.kryachko@gmail.com if you want to implement it with `num_enum` it would look something like this:\n```\n#[derive(\n    Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, FromPrimitive, IntoPrimitive, NixDeserialize, NixSerialize\n)]\n#[nix(from \u003d \"u16\", into \u003d \"u16\")]\n#[repr(u16)]\npub enum Verbosity {\n    #[num_enum(default)]\n    Error \u003d 0,\n    Warn \u003d 1,\n    Notice \u003d 2,\n    Info \u003d 3,\n    Talkative \u003d 4,\n    Chatty \u003d 5,\n    Debug \u003d 6,\n    #[num_enum(catch_all)]\n    Vomit \u003d 7,\n}\n```",
      "parentUuid": "01eba5d7_640a1b40",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6119f57e_e8076f8a",
        "filename": "tvix/nix-compat/src/nix_daemon/worker_protocol.rs",
        "patchSetId": 4
      },
      "lineNbr": 154,
      "author": {
        "id": 1000082
      },
      "writtenOn": "2024-11-06T15:55:21Z",
      "side": 1,
      "message": "@flokli@flokli.de or this hack",
      "revId": "5f790aa3beda058297e22317e60e92dd4c831ad2",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    }
  ]
}