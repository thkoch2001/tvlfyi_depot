{ depot, pkgs, ... }:

let
  inherit (depot.nix)
    getBins
    sparseTree
  ;

  inherit (depot.third_party) rustsec-advisory-db;

  bins = getBins pkgs.jq [
    "jq"
  ] // getBins pkgs.coreutils [
    "mktemp"
    "printf"
    "rm"
    "rmdir"
    "test"
  ] // getBins pkgs.nix [
    "nix-instantiate"
    "nix-store"
  ] // getBins pkgs.cargo-audit [
    "cargo-audit"
  ] // {
    eprintf = depot.tools.eprintf;
  };

  depotDeps = sparseTree depot.path.origSrc [
    "default.nix"
    "nix/readTree"
    "nix/netstring"
    "third_party/overlays"
    "third_party/nixpkgs"
    "users/sterni/nixpkgs-crate-holes/cargoDepsLockFiles"
  ];

  description = ''
    The vulnerability report below was generated by
    [nixpkgs-crate-holes](https://code.tvl.fyi/tree/users/sterni/nixpkgs-crate-holes)
    which extracts the `Cargo.lock` file of each package in nixpkgs with a
    `cargoDeps` attribute and passes it to
    [cargo-audit](https://github.com/RustSec/rustsec/tree/main/cargo-audit)
    using RustSec's
    [advisory-db at ${builtins.substring 0 7 rustsec-advisory-db.rev}](https://github.com/RustSec/advisory-db/tree/${rustsec-advisory-db.rev}/).

    Feel free to report any problems or suggest improvements (I have an email
    address on my profile and hang out on Matrix/libera.chat as sterni)!
    Tick off any reports that have been fixed in the meantime.
  '';
in

# Usage: nixpkgs-crate-holes /path/to/nixpkgs > report.md
depot.nix.writeExecline "nixpkgs-crate-holes" {
  readNArgs = 1; # $1 is nixpkgsPath
} [
  # Obtain a temporary directory where we'll be temporarily gcrooting the
  # lockfile we are currently analyzing.
  "backtick" "-E" "gcroots" [
    bins.mktemp "-d" "--tmpdir" "nixpkgs-cargoDeps-gcroots.XXXXXXXXXX"
  ]
  "if" [ bins.eprintf "Using %s as gcroot dir\n" "$gcroots" ]
  # Print introduction paragraph for the issue
  "if" [
    bins.printf "%s\n\n" description
  ]
  # cargoDepsLockFiles produces a line for each rust package in nixpkgs
  # which consists of its attribute and the drv producing its lock file
  # enconded as netstrings.
  "pipeline" [
    bins.nix-instantiate
    "--eval" "--strict" "--json" "--read-write-mode"
    depotDeps "-A" "users.sterni.nixpkgs-crate-holes.cargoDepsLockFiles"
    "--argstr" "nixpkgsPath" "$1"
    "--arg" "nixpkgsArgs" "{ allowBroken = false; }"
    "--arg" "asDerivation" "false"
  ]
  # Use jq to obtain the evaluation result as a raw string
  "pipeline" [
    bins.jq "-rj"
  ]
  "foreground" [
    "forstdin" "-E" "cargoDeps"
    "multidefine" "-d" "" "$cargoDeps" [ "attr" "drv" ]
    # cargoDepsLockFiles produces an empty drv path if cargoDeps is null,
    # which is the case for e. g. clippy, rustup, rustfmt, ...
    "ifelse" [
      bins.test "-z" "$drv"
    ] [
      bins.eprintf "%s: no cargoDeps\n" "$attr"
    ]
    # Conditional is purely for giving an status update to stderr
    "ifte" [
      "if" [ bins.eprintf "%s: no advisories found\n" "$attr" ]
    ] [
      "if" [ bins.eprintf "%s: advisories found\n" "$attr" ]
    ]
    # Actually extract the Cargo.lock file. Doing this ahead of time would be
    # faster (since it would be parallized by nix), but this approach is more
    # robust (building the lock file could fail).
    "backtick" "-i" "-E" "lockFile" [
      bins.nix-store
      "--quiet"
      "--realise" "$drv"
      "--indirect" "--add-root" "\${gcroots}/currently-processed"
    ]
    # Run cargo-audit in JSON mode and with an immutable database from 3p.
    # It's output is then converted into a markdown snippet by a “small”
    # jq script. If there's no vulnerabilities, the script's output will
    # be empty.
    "foreground" [
      "pipeline" [
        bins.cargo-audit
        "audit" "--json"
        "-n" "--db" rustsec-advisory-db
        "-f" "$lockFile"
      ]
      bins.jq "-rj" "-f" ./format-audit-result.jq "--arg" "attr" "$attr"
    ]
    bins.rm "\${gcroots}/currently-processed"
  ]
  bins.rmdir "$gcroots"
]
