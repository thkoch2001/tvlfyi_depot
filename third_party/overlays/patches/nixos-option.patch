diff --git a/CMakeLists.txt b/CMakeLists.txt
index 9aee9e6ccada..e5834598c4fd 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,11 +1,8 @@
 cmake_minimum_required (VERSION 2.6)
 project (nixos-option)
 
-set(NIX_DEV_INCLUDEPATH "" CACHE STRING "path to nix include directory")
-
 add_executable(nixos-option nixos-option.cc libnix-copy-paste.cc)
-target_include_directories(nixos-option PUBLIC "${NIX_DEV_INCLUDEPATH}")
-target_link_libraries(nixos-option PRIVATE -lnixmain -lnixexpr -lnixstore -lnixutil -lnixcmd)
-target_compile_features(nixos-option PRIVATE cxx_std_20)
+target_link_libraries(nixos-option PRIVATE -lnixmain -lnixexpr -lnixstore -lnixutil)
+target_compile_features(nixos-option PRIVATE cxx_std_17)
 
 install (TARGETS nixos-option DESTINATION bin)
diff --git a/default.nix b/default.nix
index 56cb3e130038..a9cc967d7680 100644
--- a/default.nix
+++ b/default.nix
@@ -1,18 +1,14 @@
-{ lib, stdenv, boost, cmake, pkg-config, nix }:
+{lib, stdenv, boost, cmake, pkg-config, nix, ... }:
 
-stdenv.mkDerivation {
+stdenv.mkDerivation rec {
   name = "nixos-option";
-
   src = ./.;
-
   strictDeps = true;
   nativeBuildInputs = [ cmake pkg-config ];
   buildInputs = [ boost nix ];
-  cmakeFlags = [ "-DNIX_DEV_INCLUDEPATH=${nix.dev}/include/nix" ];
-
   meta = with lib; {
     license = licenses.lgpl2Plus;
-    maintainers = with maintainers; [ ];
-    inherit (nix.meta) platforms;
+    maintainers = with maintainers; [ chkno ];
+    platforms = platforms.all;
   };
 }
diff --git a/libnix-copy-paste.cc b/libnix-copy-paste.cc
index ad6084844e57..875c07da6399 100644
--- a/libnix-copy-paste.cc
+++ b/libnix-copy-paste.cc
@@ -7,12 +7,15 @@
 #include "libnix-copy-paste.hh"
 #include <boost/format/alt_sstream.hpp>           // for basic_altstringbuf...
 #include <boost/format/alt_sstream_impl.hpp>      // for basic_altstringbuf...
+#include <boost/format/format_class.hpp>          // for basic_format
+#include <boost/format/format_fwd.hpp>            // for format
+#include <boost/format/format_implementation.hpp> // for basic_format::basi...
 #include <boost/optional/optional.hpp>            // for get_pointer
 #include <iostream>                               // for operator<<, basic_...
-#include <nix/types.hh>                           // for Strings
-#include <nix/error.hh>                           // for Error
+#include <nix/types.hh>                           // for Strings, Error
 #include <string>                                 // for string, basic_string
 
+using boost::format;
 using nix::Error;
 using nix::Strings;
 using std::string;
@@ -31,7 +34,7 @@ Strings parseAttrPath(const string & s)
             ++i;
             while (1) {
                 if (i == s.end())
-                    throw Error("missing closing quote in selection path '%1%'", s);
+                    throw Error(format("missing closing quote in selection path '%1%'") % s);
                 if (*i == '"')
                     break;
                 cur.push_back(*i++);
diff --git a/nixos-option.cc b/nixos-option.cc
index e2a73866d0ed..f779d82edbd6 100644
--- a/nixos-option.cc
+++ b/nixos-option.cc
@@ -37,26 +37,13 @@ using nix::Path;
 using nix::PathSet;
 using nix::Strings;
 using nix::Symbol;
-using nix::nAttrs;
+using nix::tAttrs;
 using nix::ThrownError;
 using nix::tLambda;
-using nix::nString;
+using nix::tString;
 using nix::UsageError;
 using nix::Value;
 
-struct Context
-{
-    Context(EvalState & state, Bindings & autoArgs, Value optionsRoot, Value configRoot)
-        : state(state), autoArgs(autoArgs), optionsRoot(optionsRoot), configRoot(configRoot),
-          underscoreType(state.symbols.create("_type"))
-    {}
-    EvalState & state;
-    Bindings & autoArgs;
-    Value optionsRoot;
-    Value configRoot;
-    Symbol underscoreType;
-};
-
 // An ostream wrapper to handle nested indentation
 class Out
 {
@@ -87,8 +74,6 @@ class Out
     LinePolicy policy;
     bool writeSinceSep;
     template <typename T> friend Out & operator<<(Out & o, T thing);
-
-    friend void printValue(Context & ctx, Out & out, std::variant<Value, std::exception_ptr> maybeValue, const std::string & path);
 };
 
 template <typename T> Out & operator<<(Out & o, T thing)
@@ -116,10 +101,23 @@ Out::Out(Out & o, const std::string & start, const std::string & end, LinePolicy
     *this << Out::sep;
 }
 
+// Stuff needed for evaluation
+struct Context
+{
+    Context(EvalState & state, Bindings & autoArgs, Value optionsRoot, Value configRoot)
+        : state(state), autoArgs(autoArgs), optionsRoot(optionsRoot), configRoot(configRoot),
+          underscoreType(state.symbols.create("_type"))
+    {}
+    EvalState & state;
+    Bindings & autoArgs;
+    Value optionsRoot;
+    Value configRoot;
+    Symbol underscoreType;
+};
 
 Value evaluateValue(Context & ctx, Value & v)
 {
-    ctx.state.forceValue(v, [&]() { return v.determinePos(nix::noPos); });
+    ctx.state.forceValue(v);
     if (ctx.autoArgs.empty()) {
         return v;
     }
@@ -130,7 +128,7 @@ Value evaluateValue(Context & ctx, Value & v)
 
 bool isOption(Context & ctx, const Value & v)
 {
-    if (v.type() != nAttrs) {
+    if (v.type != tAttrs) {
         return false;
     }
     const auto & actualType = v.attrs->find(ctx.underscoreType);
@@ -139,7 +137,7 @@ bool isOption(Context & ctx, const Value & v)
     }
     try {
         Value evaluatedType = evaluateValue(ctx, *actualType->value);
-        if (evaluatedType.type() != nString) {
+        if (evaluatedType.type != tString) {
             return false;
         }
         return static_cast<std::string>(evaluatedType.string.s) == "option";
@@ -170,14 +168,7 @@ const std::string appendPath(const std::string & prefix, const std::string & suf
     return prefix + "." + quoteAttribute(suffix);
 }
 
-bool forbiddenRecursionName(const nix::Symbol symbol, const nix::SymbolTable & symbolTable) {
-    // note: this is created from a pointer
-    // According to standard, it may never point to null, and hence attempts to check against nullptr are not allowed.
-    // However, at the time of writing, I am not certain about the full implications of the omission of a nullptr check here.
-    const std::string & name = symbolTable[symbol];
-    // TODO: figure out why haskellPackages is not recursed here
-    return (!name.empty() && name[0] == '_') || name == "haskellPackages";
-}
+bool forbiddenRecursionName(std::string name) { return (!name.empty() && name[0] == '_') || name == "haskellPackages"; }
 
 void recurse(const std::function<bool(const std::string & path, std::variant<Value, std::exception_ptr>)> & f,
              Context & ctx, Value v, const std::string & path)
@@ -195,14 +186,14 @@ void recurse(const std::function<bool(const std::string & path, std::variant<Val
         return;
     }
     const Value & evaluated_value = std::get<Value>(evaluated);
-    if (evaluated_value.type() != nAttrs) {
+    if (evaluated_value.type != tAttrs) {
         return;
     }
-    for (const auto & child : evaluated_value.attrs->lexicographicOrder(ctx.state.symbols)) {
-        if (forbiddenRecursionName(child->name, ctx.state.symbols)) {
+    for (const auto & child : evaluated_value.attrs->lexicographicOrder()) {
+        if (forbiddenRecursionName(child->name)) {
             continue;
         }
-        recurse(f, ctx, *child->value, appendPath(path, ctx.state.symbols[child->name]));
+        recurse(f, ctx, *child->value, appendPath(path, child->name));
     }
 }
 
@@ -214,7 +205,7 @@ bool optionTypeIs(Context & ctx, Value & v, const std::string & soughtType)
             return false;
         }
         Value type = evaluateValue(ctx, *typeLookup->value);
-        if (type.type() != nAttrs) {
+        if (type.type != tAttrs) {
             return false;
         }
         const auto & nameLookup = type.attrs->find(ctx.state.sName);
@@ -222,7 +213,7 @@ bool optionTypeIs(Context & ctx, Value & v, const std::string & soughtType)
             return false;
         }
         Value name = evaluateValue(ctx, *nameLookup->value);
-        if (name.type() != nString) {
+        if (name.type != tString) {
             return false;
         }
         return name.string.s == soughtType;
@@ -240,14 +231,14 @@ MakeError(OptionPathError, EvalError);
 
 Value getSubOptions(Context & ctx, Value & option)
 {
-    Value getSubOptions = evaluateValue(ctx, *findAlongAttrPath(ctx.state, "type.getSubOptions", ctx.autoArgs, option).first);
-    if (getSubOptions.isLambda()) {
+    Value getSubOptions = evaluateValue(ctx, *findAlongAttrPath(ctx.state, "type.getSubOptions", ctx.autoArgs, option));
+    if (getSubOptions.type != tLambda) {
         throw OptionPathError("Option's type.getSubOptions isn't a function");
     }
     Value emptyString{};
-    emptyString.mkString("");
+    nix::mkString(emptyString, "");
     Value v;
-    ctx.state.callFunction(getSubOptions, emptyString, v, nix::PosIdx{});
+    ctx.state.callFunction(getSubOptions, emptyString, v, nix::Pos{});
     return v;
 }
 
@@ -282,7 +273,7 @@ FindAlongOptionPathRet findAlongOptionPath(Context & ctx, const std::string & pa
                 v = subOptions;
                 // Note that we've consumed attr, but didn't actually use it.  This is the path component that's looked
                 // up in the list or attribute set that doesn't name an option -- the "root" in "users.users.root.name".
-            } else if (v.type() != nAttrs) {
+            } else if (v.type != tAttrs) {
                 throw OptionPathError("Value is %s while a set was expected", showType(v));
             } else {
                 const auto & next = v.attrs->find(ctx.state.symbols.create(attr));
@@ -345,14 +336,14 @@ void mapConfigValuesInOption(
 {
     Value * option;
     try {
-        option = findAlongAttrPath(ctx.state, path, ctx.autoArgs, ctx.configRoot).first;
+        option = findAlongAttrPath(ctx.state, path, ctx.autoArgs, ctx.configRoot);
     } catch (Error &) {
         f(path, std::current_exception());
         return;
     }
     recurse(
         [f, ctx](const std::string & path, std::variant<Value, std::exception_ptr> v) {
-            bool leaf = std::holds_alternative<std::exception_ptr>(v) || std::get<Value>(v).type() != nAttrs ||
+            bool leaf = std::holds_alternative<std::exception_ptr>(v) || std::get<Value>(v).type != tAttrs ||
                         ctx.state.isDerivation(std::get<Value>(v));
             if (!leaf) {
                 return true; // Keep digging
@@ -371,7 +362,7 @@ void describeDerivation(Context & ctx, Out & out, Value v)
     Bindings::iterator i = v.attrs->find(ctx.state.sDrvPath);
     PathSet pathset;
     try {
-        Path drvPath = i != v.attrs->end() ? ctx.state.coerceToPath(i->pos, *i->value, pathset, "while evaluating the drvPath of a derivation") : "???";
+        Path drvPath = i != v.attrs->end() ? ctx.state.coerceToPath(*i->pos, *i->value, pathset) : "???";
         out << "«derivation " << drvPath << "»";
     } catch (Error & e) {
         out << describeError(e);
@@ -399,9 +390,9 @@ void printList(Context & ctx, Out & out, Value & v)
 void printAttrs(Context & ctx, Out & out, Value & v, const std::string & path)
 {
     Out attrsOut(out, "{", "}", v.attrs->size());
-    for (const auto & a : v.attrs->lexicographicOrder(ctx.state.symbols)) {
-        if (!forbiddenRecursionName(a->name, ctx.state.symbols)) {
-            const std::string name = ctx.state.symbols[a->name];
+    for (const auto & a : v.attrs->lexicographicOrder()) {
+        std::string name = a->name;
+        if (!forbiddenRecursionName(name)) {
             attrsOut << name << " = ";
             printValue(ctx, attrsOut, *a->value, appendPath(path, name));
             attrsOut << ";" << Out::sep;
@@ -456,13 +447,13 @@ void printValue(Context & ctx, Out & out, std::variant<Value, std::exception_ptr
             describeDerivation(ctx, out, v);
         } else if (v.isList()) {
             printList(ctx, out, v);
-        } else if (v.type() == nAttrs) {
+        } else if (v.type == tAttrs) {
             printAttrs(ctx, out, v, path);
-        } else if (v.type() == nString && std::string(v.string.s).find('\n') != std::string::npos) {
+        } else if (v.type == tString && std::string(v.string.s).find('\n') != std::string::npos) {
             printMultiLineString(out, v);
         } else {
             ctx.state.forceValueDeep(v);
-            v.print(ctx.state.symbols, out.ostream);
+            out << v;
         }
     } catch (ThrownError & e) {
         if (e.msg() == "The option `" + path + "' is used but not defined.") {
@@ -514,7 +505,7 @@ void printRecursive(Context & ctx, Out & out, const std::string & path)
 void printAttr(Context & ctx, Out & out, const std::string & path, Value & root)
 {
     try {
-        printValue(ctx, out, *findAlongAttrPath(ctx.state, path, ctx.autoArgs, root).first, path);
+        printValue(ctx, out, *findAlongAttrPath(ctx.state, path, ctx.autoArgs, root), path);
     } catch (Error & e) {
         out << describeError(e);
     }
@@ -557,11 +548,11 @@ void printOption(Context & ctx, Out & out, const std::string & path, Value & opt
     out << "\n";
 }
 
-void printListing(Context & ctx, Out & out, Value & v)
+void printListing(Out & out, Value & v)
 {
     out << "This attribute set contains:\n";
-    for (const auto & a : v.attrs->lexicographicOrder(ctx.state.symbols)) {
-        const std::string & name = ctx.state.symbols[a->name];
+    for (const auto & a : v.attrs->lexicographicOrder()) {
+        std::string name = a->name;
         if (!name.empty() && name[0] != '_') {
             out << name << "\n";
         }
@@ -580,7 +571,7 @@ void printOne(Context & ctx, Out & out, const std::string & path)
         if (isOption(ctx, option)) {
             printOption(ctx, out, result.path, option);
         } else {
-            printListing(ctx, out, option);
+            printListing(out, option);
         }
     } catch (Error & e) {
         std::cerr << "error: " << e.msg()
@@ -603,7 +594,7 @@ int main(int argc, char ** argv)
         using nix::LegacyArgs::LegacyArgs;
     };
 
-    MyArgs myArgs(std::string(nix::baseNameOf(argv[0])), [&](Strings::iterator & arg, const Strings::iterator & end) {
+    MyArgs myArgs(nix::baseNameOf(argv[0]), [&](Strings::iterator & arg, const Strings::iterator & end) {
         if (*arg == "--help") {
             nix::showManPage("nixos-option");
         } else if (*arg == "--version") {
@@ -626,7 +617,7 @@ int main(int argc, char ** argv)
 
     myArgs.parseCmdline(nix::argvToStrings(argc, argv));
 
-    nix::initNix();
+    nix::initPlugins();
     nix::initGC();
     nix::settings.readOnlyMode = true;
     auto store = nix::openStore();
