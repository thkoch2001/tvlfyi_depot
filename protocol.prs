version 1 .

StringSeq = [string ...] .
StringSet = #{string} .
AttrSet = {symbol: any ...:...} .

Build = <nix-build @input string @output any> .

Realise = <realise @drv string @outputs StringSeq> .

Instantiate = <instantiate @expr string @options AttrSet @result any> .

Eval = <eval @expr string @options {symbol: any ...:...} @result any> .

Narinfo = <narinfo @path string @info AttrSet> .

Field = int / string .
Fields = [Field ...] .

ActionStart = <start @id int @level int @type int @text string @fields Fields @parent int> .
ActionStop = <stop @id int> .
ActionResult = <result @id int @type int @fields Fields> .

; TODO: why not make target a singleton?
Missing = <missing @targets StringSeq @willBuild StringSet @willSubstitute StringSet @unknown StringSet @downloadSize int @narSize int> .

; Path info for the worker protocol version 35.
LegacyPathAttrs = {
  deriver: string
  narHash: string
  references: StringSeq ; prefer a set
  registrationTime: int
  narSize: int
  ultimate: bool
  sigs: StringSet
  ca: string
} .

AddToStoreClientAttrs = {
  name: string
  eris: bytes
  ca-method: symbol
  references: StringSeq ; prefer a set
} .

; Intersection of the attributes needed to add a path to a store
; and the attributes returned by the daemon after adding the path.
AddToStoreAttrs = {
  name: string
  eris: bytes
  ca-method: symbol
  references: StringSeq ; prefer a set

  deriver: string
  narHash: string
  registrationTime: int
  narSize: int
  ultimate: bool
  sigs: StringSet
  ca: string
} .

; Any collection of attributes describing a store path.
PathInfo = <path @path string @attrs AttrSet> .
