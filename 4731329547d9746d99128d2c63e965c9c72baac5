{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8a70c230_f8a9ff06",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-09-02T21:24:51Z",
      "side": 1,
      "message": "No, this will cause massive problems with implementing a GC correctly. We can\u0027t tie the lifetime of stuff like bytecode to the lifetime of the VM without everything being either an incredible headache or unsafe, so this is not a future-proof API.\n\nWe should split `Value` into two: There\u0027s a value that contains internal variants (like `Thunk`, various stack markers, all normal Nix types, etc.) and an external value (Nix types, token values for things like \"This is unevaluated\" which you *can\u0027t do anything more with*).\n\nUsers need to specify how far they want things to be evaluated when first calling the evaluation.",
      "revId": "4731329547d9746d99128d2c63e965c9c72baac5",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "34e779c2_814b5b67",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000073
      },
      "writtenOn": "2024-09-03T09:46:32Z",
      "side": 1,
      "message": "@tazjin@tvl.su How do you suggest to implement things that needs to incrementally decide how far to go in the evaluation? Or things like I want something in-between a shallow force and a deep force, e.g. forcing `meta`, `drvPath`, `outPath` for example for a derivation, but not `passthru` necessarily?",
      "parentUuid": "8a70c230_f8a9ff06",
      "revId": "4731329547d9746d99128d2c63e965c9c72baac5",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d390eddf_d5f41eb8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-09-06T12:38:33Z",
      "side": 1,
      "message": "The only possible way to do this (this is without checking in on why you\u0027re doing this, there might be a better solution overall) is to add a builtin and synthesise a call to it around whatever expression you\u0027re evaluating.\n\nA builtin is driven by the VM, and memory owned and managed by the VM is going to be valid within that code, and functions for forcing are available there.\n\nYou can not however add an interface to eval that hands out potentially unsafe stuff like Thunks (we are already doing this, and it\u0027s a bug that will be fixed).",
      "parentUuid": "34e779c2_814b5b67",
      "revId": "4731329547d9746d99128d2c63e965c9c72baac5",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "119b204d_9d10529c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000073
      },
      "writtenOn": "2024-09-06T19:31:05Z",
      "side": 1,
      "message": "Please take a (careful) look at https://github.com/nix-community/nix-eval-jobs/blob/main/src/worker.cc ; are you suggesting that an `builtins.evalJobs` builtin should be created, and this one should *stream* JSON*L* in the VM?\n\nI understand the desire to avoid leaking internal Values from a VM but if this is opaque and transmitted to _another_ VM. You wrote \"tying the lifetime of stuff like bytecode to the lifetime of the VM\", but this is false? The VM can be torn down once you get the `Value` back. Yes, the bytecode needs to be around, though.\n\nSo, I am not yet convinced that the only way to control and drive an evaluation usefully is via a builtin or by being _inside_ a VM generator, but I agree that the solution implemented here is neither desirable, this is just a nice hack to work on getting tvix-eval-jobs right on many aspects.",
      "parentUuid": "d390eddf_d5f41eb8",
      "revId": "4731329547d9746d99128d2c63e965c9c72baac5",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3efbd30_0c17a842",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000073
      },
      "writtenOn": "2024-09-06T19:31:38Z",
      "side": 1,
      "message": "I understand the desire to avoid leaking internal Values from a VM but if this is opaque and transmitted to another VM, I think it\u0027s fine-ish. *",
      "parentUuid": "119b204d_9d10529c",
      "revId": "4731329547d9746d99128d2c63e965c9c72baac5",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a10d62f1_ef3f2ff1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000001
      },
      "writtenOn": "2024-09-13T10:52:07Z",
      "side": 1,
      "message": "\u003e The VM can be torn down once you get the Value back\n\nTechnically right now, yes, but this is *incorrect* and *unsafe* and something we need to fix, not start attempting to depend on. We need to split Value into a public Value type, and an internal value type, and make sure that the VM only returns \"safe\" values (where thunks become opaque and unevaluatable if they remain, and no internal variants can remain).\n\n\u003e but if this is opaque and transmitted to another VM\n\nThis will crash if you try it, or in the worst case lead to even weirder undefined behaviour because array indices will mismatch. You can not pair the output of one VM\u0027s compiler with another VM\u0027s runtime, and changing that is non-trivial for now.\n\n\u003e are you suggesting that an builtins.evalJobs builtin should be created, and this one should stream JSONL in the VM?\n\nYes, this sounds like a decent solution, and it\u0027s safe. Your builtin would of course only exist in the place where you are using it (i.e. it doesn\u0027t get added to eval itself, of course).",
      "parentUuid": "f3efbd30_0c17a842",
      "revId": "4731329547d9746d99128d2c63e965c9c72baac5",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cb7af2f3_7b15650b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1000073
      },
      "writtenOn": "2024-09-14T21:14:00Z",
      "side": 1,
      "message": "OK, then I guess this is a way to implement this. It just feels weird to tuck everything in a built-in and perform async IO over there.",
      "parentUuid": "a10d62f1_ef3f2ff1",
      "revId": "4731329547d9746d99128d2c63e965c9c72baac5",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    }
  ]
}