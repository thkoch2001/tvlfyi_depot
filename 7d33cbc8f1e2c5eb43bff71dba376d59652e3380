{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ebd6a2bc_0671533f",
        "filename": "tvix/glue/src/builtins/import.rs",
        "patchSetId": 61
      },
      "lineNbr": 179,
      "author": {
        "id": 1000036
      },
      "writtenOn": "2024-03-29T15:31:56Z",
      "side": 1,
      "message": "This does do raw file IO, which should go through EvalIO.\n\nPlease use `!state.read_to_end(path.as_ref()).is_err()` for now - it returns an error if the path is not a file.\n\nWe should clean this up at some point. However, I\u0027d like to do that after cl/11236 has landed (which will give us a (sync) Reader).",
      "revId": "7d33cbc8f1e2c5eb43bff71dba376d59652e3380",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fbac1089_a4af7ddf",
        "filename": "tvix/glue/src/builtins/import.rs",
        "patchSetId": 61
      },
      "lineNbr": 186,
      "author": {
        "id": 1000036
      },
      "writtenOn": "2024-03-29T15:31:56Z",
      "side": 1,
      "message": "Can you structure this a bit differently?\n\nstart with `let ca: CAHash \u003d if recursive_ingestion â€¦`, and have the match case from here become the else part of this - however it can be a B3Digest, not Option\u003eB3Digest\u003e and `return Err(ImportError::FlatImportOfNonFile(path.to_string_lossy().to_string()))` directly in the `_` arm.",
      "revId": "7d33cbc8f1e2c5eb43bff71dba376d59652e3380",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    }
  ]
}