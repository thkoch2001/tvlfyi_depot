{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "eb37600e_f7588c1d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 7,
      "author": {
        "id": 1000034
      },
      "writtenOn": "2023-12-16T11:31:29Z",
      "side": 1,
      "message": "Needs to be docs (☹️)",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 3
      },
      "revId": "e6c34806bff8353b544ac84091614627652e9f66",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "944e74d8_11f39ffb",
        "filename": "tvix/eval/src/compiler/mod.rs",
        "patchSetId": 2
      },
      "lineNbr": 346,
      "author": {
        "id": 1000034
      },
      "writtenOn": "2023-12-16T11:31:29Z",
      "side": 1,
      "message": "I think C++ usually also wraps `ExprApp` in a thunk (applications generated by primops are made using `mkApp` which is only a thunk-like thing). C++ Nix\u0027s thunking behavior is weird to compare, since `Expr*::eval` describes what happens inside an eventual thunk that is created elsewhere (i.e. `Expr*::eval` will never create the thunk for the current expression, only call `maybeThunk` for sub-expressions that need to be lazily evaluated). This means that if we look at `ExprApp::eval` we can\u0027t tell if C++ Nix thunks it, but in Tvix `ast::Expr::Apply` is the place where we decide.\n\nSide note: A side effect of this is that C++ never thunks the root expression, as you can see using `NIX_SHOW_STATS` show `nrThunks` as 0 in this example:\n\n    env NIX_SHOW_STATS\u003d1 nix-instantiate --strict --eval -E \u0027[ ]\u0027\n    \nNormally lists would be thunked.\n\nHow does thunking work then in C++ Nix? Well when evaluating an expression, say `ExprList`, C++ Nix will perform the evaluation and, for any sub-expression that _could_ need to be lazy, call `maybeThunk` to decide whether to create a thunk or not:\n\n    void ExprList::eval(EvalState \u0026 state, Env \u0026 env, Value \u0026 v)\n    {\n        state.mkList(v, elems.size());\n        for (size_t n \u003d 0; n \u003c elems.size(); ++n)\n            v.listElems()[n] \u003d elems[n]-\u003emaybeThunk(state, env);\n    }\n\n`maybeThunk` then knows the type of the sub-expression and can make them strict which is tracked using the `nrAvoided` statistic. I\u0027ve explained the strategy for avoidance [here](https://code.tvl.fyi/about/tvix/docs/value-pointer-equality.md#pointer-equality-preserving-nix-operations) as well. Unfortunately, it is not very sophisticated:\n\n* `ExprVar` is not thunked if it can immediately be replaced by the `Value` it is bound to in the scope.\n* Literals, i.e. `ExprString`, `ExprInt`, `ExprFloat`, `ExprPath` are not thunked. (`null`, `true`, `false` also aren\u0027t but this uses a different mechanism, it seems).\n* Everything else is thunked, so functions should be as well.\n\n`ExprApp::eval` is strict in the function _when_ it is evaluated (maybe you meant that?):\n\n    void ExprApp::eval(EvalState \u0026 state, Env \u0026 env, Value \u0026 v)\n    {\n        /* FIXME: vFun prevents GCC from doing tail call optimisation. */\n        Value vFun;\n        e1-\u003eeval(state, env, vFun);\n        state.callFunction(vFun, *(e2-\u003emaybeThunk(state, env)), v, pos);\n    }\n\nWhen it is called, the function is forced immediately, but the argument evaluation is delayed if `maybeThunk` agrees.\n\nConsidering the following example:\n\n    env NIX_SHOW_STATS\u003d1 nix-instantiate --strict --eval -E \u0027[ (__isInt 1) ]\u0027\n    \n* We know that the top level list won\u0027t be thunked.\n* `ExprApp` is strict in the function, so `__isInt` shouldn\u0027t be attempted to be thunked. If it was, we\u0027d see an increase in `nrAvoided`, since it can be looked up.\n* The argument, `ExprInt` would not be thunked by `maybeThunk`, so we\u0027d see `nrAvoided` go up here.\n\nWe get\n\n    \"nrThunks\": 1,\n    \"nrAvoided\": 1,\n\nThe avoided thunk is the `ExprInt` (so the function expression `__isInt` is never thunked). The sole thunk that gets created is the thunk for the list element expression `isInt 1`. Function application is thunked!",
      "range": {
        "startLine": 345,
        "startChar": 19,
        "endLine": 346,
        "endChar": 58
      },
      "revId": "e6c34806bff8353b544ac84091614627652e9f66",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "532c82a3_bc3f3545",
        "filename": "tvix/eval/src/compiler/mod.rs",
        "patchSetId": 2
      },
      "lineNbr": 352,
      "author": {
        "id": 1000034
      },
      "writtenOn": "2023-12-16T11:31:29Z",
      "side": 1,
      "message": "We could also add here that only thunking the argument would require non-tail-calls which we don\u0027t have.",
      "revId": "e6c34806bff8353b544ac84091614627652e9f66",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    }
  ]
}