{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "944147b8_336b7113",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 166
      },
      "lineNbr": 0,
      "author": {
        "id": 1000013
      },
      "writtenOn": "2023-06-29T12:40:15Z",
      "side": 1,
      "message": "Okay!",
      "revId": "54af0ddf2b0687573dff25e180f8c5df9e4822fc",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43ccdb8c_525ab30f",
        "filename": "nix/mapAttrsMaybe/default.nix",
        "patchSetId": 166
      },
      "lineNbr": 2,
      "author": {
        "id": 1000034
      },
      "writtenOn": "2023-07-02T09:06:12Z",
      "side": 1,
      "message": "I dislike that `null` can not be set as a value.",
      "revId": "54af0ddf2b0687573dff25e180f8c5df9e4822fc",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "01502b10_8b634175",
        "filename": "nix/mapAttrsMaybe/default.nix",
        "patchSetId": 166
      },
      "lineNbr": 2,
      "author": {
        "id": 1000013
      },
      "writtenOn": "2023-07-07T09:40:15Z",
      "side": 1,
      "message": "Well, it’s a tradeoff, since we only have so many values to work with.\n\nWhat other design do you have in mind? I think this one is quite natural, if you want a different value you just have to go it on foot and do the listToAttrs/filter/mapAttrsToList dance manually.",
      "parentUuid": "43ccdb8c_525ab30f",
      "revId": "54af0ddf2b0687573dff25e180f8c5df9e4822fc",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fdf5d000_61e69f1a",
        "filename": "nix/mapAttrsMaybe/default.nix",
        "patchSetId": 166
      },
      "lineNbr": 2,
      "author": {
        "id": 1000066
      },
      "writtenOn": "2023-07-08T07:24:56Z",
      "side": 1,
      "message": "I find myself wanting this function quite often.  But I also agree with sterni that using `null` here is really awkward.  What if the attrset already contains `null`s?  Then `mapAttrsMaybe (_: lib.id)` isn\u0027t the identity function.  Icky.\n\nAlternatives:\n\n1. `mapAttrsMaybe :: (k -\u003e v -\u003e [v]) -\u003e Attrs k v -\u003e Attrs k v` where you return `[]` to say \"drop it\" and a one-element list to say \"leave this\".\n  - This is expensive in cppnix (GC churn) but not in Tvix since it\u0027s just a reference count increment/decrement.\n  - Also `NixList` can (should) optimize the representation of the empty list and a one-element list whose value is of a finite-sized type (int, float, bool, null) the same way `NixAttr` already optimizes the representation of `NameValuePair`\n\n\n2. `mapAttrsMaybe :: (v -\u003e k -\u003e v -\u003e v) -\u003e Attrs k v -\u003e Attrs k v` where returning the extra argument is how you say \"drop it\" -- i.e. `mapAttrsMaybe (x: _: _: x)` applied to anything is `{}`.  The question is what marker value does `mapAttrsMaybe` pass to the functional?\n  - In Haskell we could use a rank-2 type to prevent the functional from keeping a copy of the marker value or inspecting it in any relevant way.\n  - We could abuse function equality here since it is effectively Nix\u0027s `gensym()`, but that feels pretty gross.  Or maybe just abuse function equality until some time in the future when `builtins.gensym` is ratified.",
      "parentUuid": "01502b10_8b634175",
      "revId": "54af0ddf2b0687573dff25e180f8c5df9e4822fc",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bbe2f083_d6e7d81a",
        "filename": "nix/mapAttrsMaybe/default.nix",
        "patchSetId": 166
      },
      "lineNbr": 2,
      "author": {
        "id": 1000013
      },
      "writtenOn": "2023-10-18T14:01:58Z",
      "side": 1,
      "message": "I can see how 2 would work with RankNTypes, but the API is horrid :P\n\nI’d rather make a `mapAttrsMaybe\u0027` which takes another argument, the filter predicate, and have `mapAttrsMaybe \u003d mapAttrsMaybe\u0027 (v: v !\u003d null)`.",
      "parentUuid": "fdf5d000_61e69f1a",
      "revId": "54af0ddf2b0687573dff25e180f8c5df9e4822fc",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2232404c_dc17ca0e",
        "filename": "nix/mapAttrsMaybe/default.nix",
        "patchSetId": 166
      },
      "lineNbr": 2,
      "author": {
        "id": 1000066
      },
      "writtenOn": "2023-11-25T02:31:50Z",
      "side": 1,
      "message": "I like this idea.  Maybe even split it into `filterAttrs` (which takes a predicate) and then `mapAttrsMaybe` is just `mapAttrs` composed with `filterAttrs`.\n\nAn interesting question: which do you do first, the mapping or the filtering?\n\nI suggest map-first, because this way if the user *knows* that a certain value (like `null`) will never be returned from the map functional they can use it as a \"drop this\" sentinel value.  This way you don\u0027t have to split the logic across the two functions (map and filter) -- you can just write one `if..then..else` instead of two separate ones.\n\nWhat do you think about submitting this to `\u003cnixpkgs/lib\u003e`?\n\nI would like to add an optimization to tvix to have it recognize `mapAttrsMaybe` and implement it without creating the intermediate list or attrset.  The easiest way to make the optimization predictable is to pick one specific implementation and guarantee that that particular parse tree will be optimized.  So it would be ideal if it were in `\u003cnixpkgs/lib\u003e` to discourage people from re-implementing it in a way that won\u0027t be recognized.",
      "parentUuid": "bbe2f083_d6e7d81a",
      "revId": "54af0ddf2b0687573dff25e180f8c5df9e4822fc",
      "serverId": "4fdfa107-4df9-4596-8e0a-1d2bbdd96e36"
    }
  ]
}