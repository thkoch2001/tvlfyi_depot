# It might be possible to attempt to share KBDs between `lf` and `dired`.
# Currently shared KBDs with `dired`:
#   - D: delete file
#   - R: rename file
#   - +: create directory
#   - c: create file
#
# The following command prefixes are used by lf (taken from the docs):
#
#    :  read (default)  builtin/custom command
#    $  shell           shell command
#    %  shell-pipe      shell command running with the ui
#    !  shell-wait      shell command waiting for key press
#    &  shell-async     shell command running asynchronously
#    /  search          search file in current directory
#    ?  search-back     search file in the reverse order
#
# `x` will be used as a generic prefix KBD for most of my user-defined KBDs. Do
# not map anything to just `x`. Instead prefer `x<char>`. Mneumonically, "x" is
# intended to resemble "eXecute".
#
# If `x<char>` does one thing; `x<uppercase-char>` should do the opposite when
# possible. This is convenient for things that pass the round-trip test like
# encrypt/decrypt, archive/unarchive.

# TODO: move most of these commands to function.zsh and call those functions
# herein. Especially the `archive` and `extract` functions.
#
# TODO: consider integrations with `xdg-open` and configuring filetypes to
# behave in expected "dwim" ways.
#
# TODO: learn more about the terms "archive", "compress", "decompress",
# "expand", "extract", etc. See if a larger abstraction can be created on top
# without sacrificing too much nuance. This might be the case of "serialize",
# "deserialize", "pickle", "unpickle", "marshal", "unmarshal", "encode",
# "decode" -- in which case, a broader abstraction would be nice to decrease the
# surface area of the vocabulary.
#
# TODO: find a way to visualize all of the bound or unbound KBDs.
#
# TODO: support polymorphic way encrypt/decrypt a file or directory.
#
# TODO: support "toggle" for encryption/decryption that detects which function
# to run based on the extension.
#
# TODO: support "toggle" for archive/unarchive that detects which function to
# run based on the extension.

# Basic configuration
set hidden on

# Arguably the most import function herein
cmd help $lf -doc | less

# delete a file, dir
map D delete

cmd rename %{{
    # Renames files, dirs.
    set -f
    if [ -e "$1" ]; then
      printf 'file exists'
    else
      mv "$f" "$1"
    fi
}}
map R push :rename<space>

cmd mkdir %{{
    mkdir -p "$1"
}}
map + push :mkdir<space>

cmd touch %{{
    # Create a file
    touch "$1"
}}
map c push :touch<space>

cmd encrypt_file %{{
  # Encrypts the file and deletes the cleartext version.
  # Run `decrypt_file` to return the file to its cleartext version.
  printf "recipient: "
  read recipient
  gpg --encrypt --recipient "$recipient" "$f" && rm "$f"
}}
map xe :encrypt_file

cmd decrypt_file %{{
  # Decrypts a file that was encrypted with `encrypt_file`.
  # Assumes encrypted files have the .gpg extension and decrypted files omit the
  # .gpg extension.
  # Deletes the original .gpg file when finished.

  # check if file exists without .gpg extension
  if [ -e "${f%.gpg}" ]; then
    printf "${f%.gpg} exists. Consider deleting or renaming it. Aborting..."
  else
    gpg --decrypt "$f" >"${f%.gpg}" 2>/dev/null && rm "$f"
  fi
}}
map xE :decrypt_file

cmd archive %{{
    # Generic function for archiving directories.
    # TODO: support selections of multiple files.
    set -f
    printf "Which type of archive would you like to create? (tar,tar.gz,zip) "
    read answer
    case $answer in
         tar.gz) tar -czf "$f.tar.gz" "$(basename $f)"; rm -rf "$f";;
         tar)    tar -cf "$f.tar" "$(basename $f)"; rm -rf "$f";;
         zip)    zip -r "$f.zip" "$(basename $f)"; rm -rf "$f";;
         *)      printf "\"$1\" is not a support archive. Aborting..."
    esac
}}
map xa :archive

cmd unarchive %{{
    # Generic function for extracting archived directories.
    # Assumes directories were archived with the `archive`.
    set -f
    case $f in
         *.tar.gz) tar -xzvf $f; rm "$f";;
         *.tar)    tar -xvf  $f; rm "$f";;
         *.zip)    unzip "$f"; rm "$f";;
         # TODO: grab extension from $f and display it in `printf` call.
         *)        printf "Unsupported archive type. Aborting..."
    esac
}}
map xA: unarchive

cmd tar %{{
    # tars a directory
    set -f
    printf "gzip? (y,n) "
    read answer
    case $answer in
         y) tar -czf "$f.tar.gz" "$(basename $f)"; rm -rf "$f";;
         n) tar -cf  "$f.tar"    "$(basename $f)"; rm -rf "$f";;
         *) printf "\"$answer\" is not a supported answer. Aborting...";;
    esac
}}
map xt :tar

cmd untar %{{
    # untars a directory tar'd with `tar`.
    set -f
    case $f in
         *.tar.gz) tar -xzvf $f; rm "$f";;
         *.tar)    tar -xvf  $f; rm "$f";;
    esac
}}
map xT :untar

cmd zip %{{
    # zip a directory
    set -f
    zip -r "$f.zip" "$(basename $f)"
    rm -rf "$f"
}}
map xz :zip

cmd unzip %{{
    # unzip a directory
    set -f
    unzip "$f"
    rm "$f"
}}
map xZ :unzip

# outputs the size of a particular file, dir
# TODO: consider mapping this to a KBD
cmd size %du -hs "$f"
map xs :size
